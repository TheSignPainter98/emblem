use crate::parser::{Location, LexicalError, lexer};
use crate::ast::{
    parsed::{MultiLineComment, MultiLineCommentPart, Content},
    File, Par,
};
use crate::context::Context;
use std::error::Error;

grammar<'input>;

pub File: File<Content<'input>> = {
	MaybeSepList<Par, ParBreak> => File {
		pars: <>,
	},
};

Par: Par<Content<'input>> = {
	ParContent => Par { content: <> },
};

ParContent: Vec<Content<'input>> = {
	SepList<Content, Whitespace>
};

Content: Content<'input> = {
	NestedComment => Content::MultiLineComment(<>),
	// !             => {
	// 	errors.push("something went wrong");
	// 	Content::Error
	// }
}

Args = {
	("{" <Content+> "}")* (":" <Indented<ParContent>> ("::" <Indented<ParContent>>)*)?
}

NestedComment: MultiLineComment<'input> = {
	"/*" <NestedCommentContent> "*/"
}

NestedCommentContent: MultiLineComment<'input> = {
	<NestedCommentPart*> => MultiLineComment(<>),
}

NestedCommentPart: MultiLineCommentPart<'input> = {
	"\n"                                 => MultiLineCommentPart::Newline,
	Comment                              => MultiLineCommentPart::Comment(<>),
	Indent <NestedCommentContent> Dedent => MultiLineCommentPart::Indented(<>),
	NestedComment                        => MultiLineCommentPart::Nested(<>),
}

SepList<T,Sep>: Vec<T> = {
	<head:T> <mut tail:MaybeSepList<T,Sep>> => {
		let mut ret = vec![head];
		ret.append(&mut tail);
		ret
	}
}

MaybeSepList<T, Sep>: Vec<T> = {
	<mut init:(<T> Sep)*> <last:T?> => match last {
		None => init,
		Some(e) => {
			init.push(e);
			init
		}
	},
}

Indented<T>: T = {
	Indent <MaybeIndented<T>> Dedent,
}

MaybeIndented<T>: T = {
	T,
	Indent <MaybeIndented<T>> Dedent,
}

extern {
	type Location = Location<'input>;
	type Error = LexicalError<'input>;

	enum lexer::Tok<'input> {
		Indent     => lexer::Tok::Indent,
		Dedent     => lexer::Tok::Dedent,
		":"        => lexer::Tok::Colon,
		"::"       => lexer::Tok::DoubleColon,
		"{"        => lexer::Tok::LBrace,
		"}"        => lexer::Tok::RBrace,
		Command    => lexer::Tok::Command(<&'input str>),
		ParBreak   => lexer::Tok::ParBreak,
		Word       => lexer::Tok::Word(<&'input str>),
		Whitespace => lexer::Tok::Whitespace(<&'input str>),
		"/*"       => lexer::Tok::NestedCommentOpen,
		"*/"       => lexer::Tok::NestedCommentClose,
		"\n"       => lexer::Tok::Newline,
		Comment    => lexer::Tok::Comment(<&'input str>),
	}
}
