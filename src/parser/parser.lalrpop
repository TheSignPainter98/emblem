use crate::parser::{Location, LexicalError, lexer::Tok};
use crate::ast::{
    parsed::{Attrs, Attr, ParsedFile, MultiLineComment, MultiLineCommentPart, Content},
    Par, ParPart, Text, Dash, Glue,
};

grammar<'input>;

pub File: ParsedFile<'input> = {
    FileContent => ParsedFile { pars: <> },
};

FileContent: Vec<Par<ParPart<Content<'input>>>> = {
	MaybeSepList<Par, ParBreak>
}

Par: Par<ParPart<Content<'input>>> = {
	ParPart+ => Par::from(<>),
}

ParPart: ParPart<Content<'input>> = {
	<err: ErraticIndent?> <content: MaybeLineContent> "\n" => {
		ParPart::Line({
			if let Some(err) = err {
				let mut ret: Vec<Content<'_>> = Vec::with_capacity(1 + content.len());
				ret.push(Content::ErraticIndent(err));
				ret.extend(content);
				ret
			} else {
				content
			}
		})
	},

	<erratic_indent: ErraticIndent?> <name:Command> <attrs:Attrs?> <inline_args:("{" <MaybeLineContent> "}")*> ":" "\n" <trail_head:Indented<FileContent>> <trail_tail:("::" "\n" <Indented<FileContent>>)*> => {
		ParPart::Command(Content::Command {
			name: Text::from(name),
			attrs,
			inline_args,
			remainder_arg: None,
			trailer_args: {
				let mut args = vec![trail_head];
				args.extend(trail_tail);
				args
			},
			erratic_indent
		})
	},
}

MaybeLineContent: Vec<Content<'input>> = {
	LineContent? => <>.unwrap_or_default()
}

LineContent: Vec<Content<'input>> = {
	LineElement+,
	<mut content:LineElement*> <tail:RemainderCommand> => {
		content.push(tail);
		content
	},
}

RemainderCommand: Content<'input> = {
	<name:Command> <attrs:Attrs?> <inline_args:("{" <MaybeLineContent> "}")*> <remainder_arg:(":" <LineContent>)> => Content::Command {
		name: Text::from(name),
		attrs,
		inline_args,
		remainder_arg: Some(remainder_arg),
		trailer_args: Vec::with_capacity(0),
		erratic_indent: None,
	}
}

LineElement: Content<'input> = {
	Comment       => Content::Comment(<>),
	NestedComment => Content::MultiLineComment(<>),
	Whitespace    => Content::Whitespace(<>),
	Word          => Content::Word(Text::from(<>)),
	Dash          => Content::Dash(Dash::from(<>)),
	Glue          => Content::Glue(Glue::from(<>)),
	Verbatim      => Content::Verbatim(<>),

	<name: Command> <attrs:Attrs?> <inline_args:("{" <MaybeLineContent> "}")*> => Content::Command {
		name: Text::from(name),
		attrs,
		inline_args,
		remainder_arg: None,
		trailer_args: Vec::with_capacity(0),
		erratic_indent: None,
	},
}

Attrs: Attrs<'input> = {
	"[" <MaybeSepList<Attr, ",">> "]" => Attrs::new(<>),
}

Attr: Attr<'input> = {
	NamedAttr => Attr::named(<>),
	UnnamedAttr => Attr::unnamed(<>),
};

NestedComment: MultiLineComment<'input> = {
	"/*" <NestedCommentContent> "*/"
}

NestedCommentContent: MultiLineComment<'input> = {
	<NestedCommentPart*> => MultiLineComment(<>),
}

NestedCommentPart: MultiLineCommentPart<'input> = {
	"\n"          => MultiLineCommentPart::Newline,
	Comment       => MultiLineCommentPart::Comment(<>),
	NestedComment => MultiLineCommentPart::Nested(<>),
}

SepList<T,Sep>: Vec<T> = {
	<head:T> <mut tail:MaybeSepList<T,Sep>> => {
		let mut ret = vec![head];
		ret.append(&mut tail);
		ret
	},
}

MaybeSepList<T, Sep>: Vec<T> = {
	<mut init:(<T> Sep)*> <last:T?> => match last {
		None => init,
		Some(e) => {
			init.push(e);
			init
		}
	},
}

Indented<T>: T = {
	Indent <MaybeIndented<T>> Dedent,
}

MaybeIndented<T>: T = {
	T,
	Indent <MaybeIndented<T>> Dedent,
}

extern {
	type Location = Location<'input>;
	type Error = LexicalError<'input>;

	enum Tok<'input> {
		Indent        => Tok::Indent(<&'input str>),
		Dedent        => Tok::Dedent(<&'input str>),
		ErraticIndent => Tok::ErraticIndent(<&'input str>),
		":"           => Tok::Colon(<&'input str>),
		"::"          => Tok::DoubleColon(<&'input str>),
		"{"           => Tok::LBrace,
		"}"           => Tok::RBrace,
		Command       => Tok::Command(<&'input str>),
		ParBreak      => Tok::ParBreak(<&'input str>),
		Word          => Tok::Word(<&'input str>),
		Dash          => Tok::Dash(<&'input str>),
		Glue          => Tok::Glue(<&'input str>),
		Verbatim      => Tok::Verbatim(<&'input str>),
		Whitespace    => Tok::Whitespace(<&'input str>),
		"["           => Tok::LBracket,
		"]"           => Tok::RBracket,
		","           => Tok::AttrComma,
		NamedAttr     => Tok::NamedAttr(<&'input str>),
		UnnamedAttr   => Tok::UnnamedAttr(<&'input str>),
		"/*"          => Tok::NestedCommentOpen,
		"*/"          => Tok::NestedCommentClose,
		"\n"          => Tok::Newline,
		Comment       => Tok::Comment(<&'input str>),
	}
}
