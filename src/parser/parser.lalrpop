use crate::parser::{Location, LexicalError, lexer::Tok};
use crate::ast::{
    parsed::{MultiLineComment, MultiLineCommentPart, Content},
    File, Par, Line, Text, Dash, Glue,
};

grammar<'input>;

pub File: File<Content<'input>> = {
    FileContent => File { pars: <> },
};

FileContent: Vec<Par<Content<'input>>> = {
	MaybeSepList<Par, ParBreak>
}

Par: Par<Content<'input>> = {
	Line+ => Par::from(<>),
}

Line: Line<Content<'input>> = {
	<mut content:LineElement*> <tail:RemainderCommand?> "\n" => {
		if let Some(cmd) = tail {
			content.push(cmd);
		}
		Line::from(content)
	},

	<name:Command> <inline_args:("{" <LineElement*> "}")*> ":" "\n" <trail_head:Indented<FileContent>> <trail_tail:("::" "\n" <Indented<FileContent>>)*> => {
		let name = Text::from(name);
		let remainder_arg = None;
		let trailing_args = {
			let mut trailing_args = vec![trail_head];
			trailing_args.extend(trail_tail);
			trailing_args
		};

		Line::from(Content::Command { name, inline_args, remainder_arg, trailing_args })
	},
}

RemainderCommand: Content<'input> = {
	<name:Command> <mut inline_args:("{" <LineElement*> "}")*> <remainder_arg:(":" <LineElement+>)> => {
		let name = Text::from(name);
		let remainder_arg = Some(remainder_arg);
		Content::Command { name, inline_args, remainder_arg, trailing_args: Vec::with_capacity(0) }
	}
}

LineElement: Content<'input> = {
	Comment       => Content::Comment(<>),
	NestedComment => Content::MultiLineComment(<>),
	Whitespace    => Content::Whitespace(<>),
	Word          => Content::Word(Text::from(<>)),
	Dash          => Content::Dash(Dash::from(<>)),
	Glue          => Content::Glue(Glue::from(<>)),
	Verbatim      => Content::Verbatim(<>),

	<name: Command> <inline_args:("{" <LineElement*> "}")*> => Content::Command {
		name: Text::from(name),
		inline_args,
		remainder_arg: None,
		trailing_args: Vec::with_capacity(0),
	},

	// ! => {
	// 	errors.push("something went wrong");
	// 	Content::Error
	// }
}

NestedComment: MultiLineComment<'input> = {
	"/*" <NestedCommentContent> "*/"
}

NestedCommentContent: MultiLineComment<'input> = {
	<NestedCommentPart*> => MultiLineComment(<>),
}

NestedCommentPart: MultiLineCommentPart<'input> = {
	"\n"          => MultiLineCommentPart::Newline,
	Comment       => MultiLineCommentPart::Comment(<>),
	NestedComment => MultiLineCommentPart::Nested(<>),
}

SepList<T,Sep>: Vec<T> = {
	<head:T> <mut tail:MaybeSepList<T,Sep>> => {
		let mut ret = vec![head];
		ret.append(&mut tail);
		ret
	}
}

MaybeSepList<T, Sep>: Vec<T> = {
	<mut init:(<T> Sep)*> <last:T?> => match last {
		None => init,
		Some(e) => {
			init.push(e);
			init
		}
	},
}

Indented<T>: T = {
	Indent <MaybeIndented<T>> Dedent,
}

MaybeIndented<T>: T = {
	T,
	Indent <MaybeIndented<T>> Dedent,
}

extern {
	type Location = Location<'input>;
	type Error = LexicalError<'input>;

	enum Tok<'input> {
		Indent     => Tok::Indent,
		Dedent     => Tok::Dedent,
		":"        => Tok::Colon,
		"::"       => Tok::DoubleColon,
		"{"        => Tok::LBrace,
		"}"        => Tok::RBrace,
		Command    => Tok::Command(<&'input str>),
		ParBreak   => Tok::ParBreak,
		Word       => Tok::Word(<&'input str>),
		Dash       => Tok::Dash(<&'input str>),
		Glue       => Tok::Glue(<&'input str>),
		Verbatim   => Tok::Verbatim(<&'input str>),
		Whitespace => Tok::Whitespace(<&'input str>),
		"/*"       => Tok::NestedCommentOpen,
		"*/"       => Tok::NestedCommentClose,
		"\n"       => Tok::Newline,
		Comment    => Tok::Comment(<&'input str>),
	}
}
